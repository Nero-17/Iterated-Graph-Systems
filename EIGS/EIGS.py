# iterated_graph_systems/igs.py

import random
from math import floor

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np


def substitute_edge(G, u, v, rule, next_node_label):
    """
    Replace an edge (u, v) in G according to the given rule.

    Parameters
    ----------
    G : networkx.Graph or networkx.DiGraph
        The graph in which the substitution is performed.
    u, v : hashable
        Endpoints of the edge to be replaced.
    rule : dict
        Substitution rule of the form:
            {
                "planting": (planting_start, planting_end),
                "edge_list": [(a, b, color), ...]
            }
        planting_start and planting_end are identified with u, v.
        All other vertices in edge_list receive new labels.
    next_node_label : int
        Next available integer label for newly created vertices.

    Returns
    -------
    next_node_label : int
        Updated next free label after inserting all new vertices.
    """
    planting_start, planting_end = rule["planting"]

    # Map seed-graph vertices to main-graph vertices
    mapping = {}
    mapping[planting_start] = u
    mapping[planting_end] = v

    # Assign new labels to all other vertices appearing in edge_list
    for edge in rule["edge_list"]:
        for node in (edge[0], edge[1]):
            if node not in mapping:
                mapping[node] = next_node_label
                next_node_label += 1

    # Add edges according to the seed rule, with their colours
    for a, b, edge_color in rule["edge_list"]:
        new_a = mapping[a]
        new_b = mapping[b]
        G.add_edge(new_a, new_b, color=edge_color)

    return next_node_label


def count_new_vertices_in_rule(rule):
    """
    Count how many 'new' vertices a rule introduces, i.e.
    all vertices in edge_list except the two planting endpoints.

    Parameters
    ----------
    rule : dict
        Substitution rule with keys "planting" and "edge_list".

    Returns
    -------
    int
        Number of distinct vertices in edge_list that are not
        the planting endpoints.
    """
    planting_start, planting_end = rule["planting"]
    vertices = set()
    for a, b, _color in rule["edge_list"]:
        vertices.add(a)
        vertices.add(b)
    new_vertices = vertices - {planting_start, planting_end}
    return len(new_vertices)


def Edge_Iterated_Graph_Systems(
    rules_graphs,
    initial_colour,
    iterations,
    direction="on",
    colour="on",
):
    """
    Construct an edge-based Iterated Graph System (IGS) from rule graphs.

    Parameters
    ----------
    rules_graphs : dict
        Dictionary of substitution rules keyed by edge colour, e.g.

            rules_graphs = {
                "blue": {
                    "planting": ("start", "end"),
                    "edge_list": [
                        ("start", "A", "blue"),
                        ("A", "B", "red"),
                        ("B", "end", "blue"),
                        ("start", "C", "red"),
                        ("C", "end", "red"),
                    ],
                },
                "red": {
                    "planting": ("start", "end"),
                    "edge_list": [
                        ("B", "start", "red"),
                        ("C", "B", "red"),
                        ("C", "D", "red"),
                        ("E", "D", "red"),
                        ("end", "E", "blue"),
                        ("start", "F", "blue"),
                        ("G", "F", "blue"),
                        ("H", "G", "blue"),
                        ("H", "I", "blue"),
                        ("I", "end", "red"),
                    ],
                },
            }

        Each rule describes how an edge of that colour is replaced.

    initial_colour : str
        Colour of the initial edge. The initial graph is:
        two nodes (1, 2) and one edge (1, 2) with color=initial_colour.

    iterations : int
        Number of substitution steps.

    direction : {'on', 'off'}, optional
        "on"  -> keep the graph directed (DiGraph).
        "off" -> convert to an undirected graph at the end.

    colour : {'on', 'off'}, optional
        Controls whether edge colours are kept in the output graph:
        - "on"  -> keep the 'color' attribute as generated by the rules;
        - "off" -> set all edge 'color' attributes to 'black'.

    Returns
    -------
    G : networkx.Graph or networkx.DiGraph
        The final iterated graph.
    """
    # Start from a directed graph with a single coloured edge
    G = nx.DiGraph()
    G.add_nodes_from([1, 2])
    G.add_edge(1, 2, color=initial_colour)
    next_node_label = 3

    for _ in range(iterations):
        # Take a snapshot of current edges so we can safely modify G
        current_edges = list(G.edges(data=True))
        for (u, v, attr) in current_edges:
            edge_color = attr.get("color")
            if edge_color in rules_graphs:
                # Substitute according to the matching rule
                next_node_label = substitute_edge(
                    G, u, v, rules_graphs[edge_color], next_node_label
                )

            # Remove the original edge (u, v) if it still exists
            if G.has_edge(u, v):
                G.remove_edge(u, v)

    # Optionally convert to undirected at the end
    if direction == "off":
        G = G.to_undirected()

    # Optionally forget colours by overwriting them with 'black'
    if colour == "off":
        for u, v in G.edges():
            G[u][v]["color"] = "black"

    return G


def draw_IGS(G, layout, direction="on", colour="on"):
    """
    Draw an IGS graph with a given layout.

    Parameters
    ----------
    G : networkx.Graph or DiGraph
        Graph produced by Edge_Iterated_Graph_Systems.
    layout : dict
        Dictionary mapping node -> 2D position (e.g. spring layout).
    direction : {'on', 'off'}
        "on"  -> draw arrows (for directed graphs).
        "off" -> draw as an undirected graph (no arrows).
    colour : {'on', 'off'}
        "on"  -> use edge 'color' attribute when drawing;
        "off" -> draw all edges in black.
    """
    plt.figure(figsize=(8, 6))

    if colour == "on":
        edge_colors = [
            attr.get("color", "black")
            for _, _, attr in G.edges(data=True)
        ]
    else:
        edge_colors = "black"

    arrow_flag = (direction == "on")

    nx.draw(
        G,
        layout,
        with_labels=False,
        edge_color=edge_colors,
        node_size=1,
        arrows=arrow_flag,
    )
    plt.title("Iterated Graph Systems")
    plt.axis("off")
    plt.show()


def draw_bond_percolation(G, p=0.6, layout=None, ax=None):
    """
    Draw one Bernoulli bond percolation realisation on G.

    Parameters
    ----------
    G : networkx.Graph
        Original graph.
    p : float
        Edge retention probability (default 0.6).
    layout : dict or None
        Node position dictionary. If None, a spring layout is computed.
    ax : matplotlib.axes.Axes or None
        Axis to draw on. If None, a new figure is created.
    """
    if ax is None:
        fig, ax = plt.subplots(figsize=(8, 6))

    if layout is None:
        layout = nx.spring_layout(G, scale=2)

    occupied_edges = []
    removed_edges = []
    for edge in G.edges():
        if random.random() < p:
            occupied_edges.append(edge)
        else:
            removed_edges.append(edge)

    nx.draw_networkx_nodes(
        G,
        layout,
        node_color="lightblue",
        node_size=1,
        ax=ax,
    )
    nx.draw_networkx_edges(
        G,
        layout,
        edgelist=occupied_edges,
        style="solid",
        width=2,
        edge_color="red",
        ax=ax,
    )
    nx.draw_networkx_edges(
        G,
        layout,
        edgelist=removed_edges,
        style="dashed",
        width=1,
        edge_color="black",
        ax=ax,
    )
    ax.set_title(f"Bond Percolation (p = {p})")
    ax.axis("off")
